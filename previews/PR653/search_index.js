var documenterSearchIndex = {"docs":
[{"location":"References/#References","page":"References","title":"References","text":"","category":"section"},{"location":"References/","page":"References","title":"References","text":"","category":"page"},{"location":"Closures/#Adding-closures-to-EDMF","page":"Closures","title":"Adding closures to EDMF","text":"","category":"section"},{"location":"Closures/","page":"Closures","title":"Closures","text":"Entrainment closure functions are written in a file that can be augmented with additional closure types. The type of entrainment closure is specified in the namelist, which is a collection of model parameters, flags, and other options used to run EDMF. After the new closure is implemented, EDMF can be run with your new closure by running julia --project integration_tests/LES_driven_SCM.jl in the top level of the repo.","category":"page"},{"location":"Closures/#Adding-a-general-closure-function:","page":"Closures","title":"Adding a general closure function:","text":"","category":"section"},{"location":"Closures/","page":"Closures","title":"Closures","text":"1.) Add a entr_detr function defintion to src/closures/entr_detr.jl which implements your closure. The code uses multiple  dispatch to determine which type of entrainment to used based on the εδ_model_type argument. All entr_detr  definitions must take: \t\tparam_set (a collection of parameters, many of which are defined in the namelist, as well as parameters needed for your closure) \t\tεδ_model_vars - a structure containing all input variables your closure might depend on.  \t\tεδ_model_type - a type specifying the closure, defined in src/types.jl","category":"page"},{"location":"Closures/","page":"Closures","title":"Closures","text":"Currently, the closures we're after are functions of local, non-dimensional groups of the prognostic model variables. These are returned by the non_dimensional_groups function. New ML models should take these non-dimensional groups as inputs and return two continuous, non-negative outputs (one for entrainment nondim_ε and  one for detrainment nondim_δ). Note we are not modifying the dimensional part of entrainment/detrainment (dim_scale), but only the non-dimensional component multiplying it.","category":"page"},{"location":"Closures/","page":"Closures","title":"Closures","text":"function entr_detr(param_set, εδ_model_vars, εδ_model_type::<YourClosureType>)\n\tc_gen = ICP.c_gen(param_set)\n\tdim_scale = dimensional_part(param_set, εδ_model_vars)\n\tarea_limiter = max_area_limiter(param_set, εδ_model_vars)\n\n\tfoo =  <Your Non-Dimensional Function>\n\n\tnondim_groups = non_dimensional_groups(param_set, εδ_model_vars)\n\tnondim_ε, nondim_δ = <foo(nondim_groups)>\n\n\t# dynamic entrainment / detrainment\n\tε_dyn = dim_scale * nondim_ε\n\tδ_dyn = dim_scale * nondim_δ + area_limiter\n\n\t# turbulent entrainment\n\tε_turb, K_ε = compute_turbulent_entrainment(param_set, εδ_model_vars)\n\n\treturn EntrDetr(ε_dyn, δ_dyn, ε_turb, K_ε)\nend","category":"page"},{"location":"Closures/","page":"Closures","title":"Closures","text":"Most of this code is boiler plate - you only need to make changes at the bracketed components. c_gen is a vector of parameters needed for your closure, specified in the namelist. ","category":"page"},{"location":"Closures/","page":"Closures","title":"Closures","text":"2.) Update driver/generate_namelist.jl to specify your closure type and initial parameters.  Add initial parameters as the c_gen namelist argument as a vector.","category":"page"},{"location":"Closures/","page":"Closures","title":"Closures","text":"namelist_defaults[\"turbulence\"][\"EDMF_PrognosticTKE\"][\"entrainment\"] = <Name of your closure>","category":"page"},{"location":"Closures/","page":"Closures","title":"Closures","text":". . .","category":"page"},{"location":"Closures/","page":"Closures","title":"Closures","text":"namelist_defaults[\"turbulence\"][\"EDMF_PrognosticTKE\"][\"general_ent_params\"] = <Your initial parameters.>","category":"page"},{"location":"Closures/","page":"Closures","title":"Closures","text":"3.) Add a type definition for your closure in src/types.jl Create a struct with a unique name for your closure.","category":"page"},{"location":"Closures/","page":"Closures","title":"Closures","text":"struct <YourClosureType> end","category":"page"},{"location":"Closures/","page":"Closures","title":"Closures","text":". . . Add logic that maps namelist entrainment name to the type you defined above. ","category":"page"},{"location":"Closures/","page":"Closures","title":"Closures","text":"elseif entr_type == <Name of your closure>\n\t<YourClosureType>","category":"page"},{"location":"Closures/#An-example:-Simple-Neural-Network-Closure","page":"Closures","title":"An example: Simple Neural Network Closure","text":"","category":"section"},{"location":"Closures/","page":"Closures","title":"Closures","text":"Here we've added a simple neural network which maps non-dimensional groups (nondim_groups) to the non-dimensional components of entrainment & detrainment (nondim_ε & nondim_δ, respectively).  The entrainment type is NNEntr and the namelist name is \"NN\".","category":"page"},{"location":"Closures/#src/closures/entr_detr.jl","page":"Closures","title":"src/closures/entr_detr.jl","text":"","category":"section"},{"location":"Closures/","page":"Closures","title":"Closures","text":"function entr_detr(param_set, εδ_model_vars, εδ_model_type::NNEntr)\n    c_gen = ICP.c_gen(param_set)\n    dim_scale = dimensional_part(param_set, εδ_model_vars)\n    area_limiter = max_area_limiter(param_set, εδ_model_vars)\n\n    # Neural network closure\n    nn_arc = (4, 2, 2)  # (#inputs, #neurons, #outputs)\n    nn_model = Chain(\n        Dense(reshape(c_gen[1:8], nn_arc[2], nn_arc[1]), c_gen[9:10], sigmoid),\n        Dense(reshape(c_gen[11:14], nn_arc[3], nn_arc[2]), c_gen[15:16], softplus),\n    )\n\n    nondim_groups = non_dimensional_groups(param_set, εδ_model_vars)\n    nondim_ε, nondim_δ = nn_model(nondim_groups)\n\n    # dynamic entrainment / detrainment\n    ε_dyn = dim_scale * nondim_ε\n    δ_dyn = dim_scale * nondim_δ + area_limiter\n\n    # turbulent entrainment\n    ε_turb, K_ε = compute_turbulent_entrainment(param_set, εδ_model_vars)\n\n    return EntrDetr(ε_dyn, δ_dyn, ε_turb, K_ε)\nend","category":"page"},{"location":"Closures/#driver/generate_namelist.jl","page":"Closures","title":"driver/generate_namelist.jl","text":"","category":"section"},{"location":"Closures/","page":"Closures","title":"Closures","text":"namelist_defaults[\"turbulence\"][\"EDMF_PrognosticTKE\"][\"entrainment\"] = \"NN\" ","category":"page"},{"location":"Closures/","page":"Closures","title":"Closures","text":".  . .","category":"page"},{"location":"Closures/","page":"Closures","title":"Closures","text":"namelist_defaults[\"turbulence\"][\"EDMF_PrognosticTKE\"][\"general_ent_params\"] =\n\tSA.SVector(0.3038, 0.719,-0.910,-0.483,\n\t\t\t\t0.739, 0.0755, 0.178, 0.521,\n\t\t\t\t0.0, 0.0, 0.843,-0.340,\n\t\t\t\t0.655, 0.113, 0.0, 0.0)","category":"page"},{"location":"Closures/#src/types.jl","page":"Closures","title":"src/types.jl","text":"","category":"section"},{"location":"Closures/","page":"Closures","title":"Closures","text":"struct NNEntr end","category":"page"},{"location":"Closures/","page":"Closures","title":"Closures","text":". . .","category":"page"},{"location":"Closures/","page":"Closures","title":"Closures","text":"elseif entr_type == \"NN\"\n    NNEntr()","category":"page"},{"location":"ReferenceStates/#Reference-States","page":"Reference states","title":"Reference States","text":"","category":"section"},{"location":"ReferenceStates/","page":"Reference states","title":"Reference states","text":"include(\"PlotReferenceStates.jl\")","category":"page"},{"location":"ReferenceStates/#Bomex","page":"Reference states","title":"Bomex","text":"","category":"section"},{"location":"ReferenceStates/","page":"Reference states","title":"Reference states","text":"(Image: )","category":"page"},{"location":"ReferenceStates/#life_cycle_Tan2018","page":"Reference states","title":"life_cycle_Tan2018","text":"","category":"section"},{"location":"ReferenceStates/","page":"Reference states","title":"Reference states","text":"(Image: )","category":"page"},{"location":"ReferenceStates/#Soares","page":"Reference states","title":"Soares","text":"","category":"section"},{"location":"ReferenceStates/","page":"Reference states","title":"Reference states","text":"(Image: )","category":"page"},{"location":"ReferenceStates/#Rico","page":"Reference states","title":"Rico","text":"","category":"section"},{"location":"ReferenceStates/","page":"Reference states","title":"Reference states","text":"(Image: )","category":"page"},{"location":"ReferenceStates/#TRMM_LBA","page":"Reference states","title":"TRMM_LBA","text":"","category":"section"},{"location":"ReferenceStates/","page":"Reference states","title":"Reference states","text":"(Image: )","category":"page"},{"location":"ReferenceStates/#ARM_SGP","page":"Reference states","title":"ARM_SGP","text":"","category":"section"},{"location":"ReferenceStates/","page":"Reference states","title":"Reference states","text":"(Image: )","category":"page"},{"location":"ReferenceStates/#GATE_III","page":"Reference states","title":"GATE_III","text":"","category":"section"},{"location":"ReferenceStates/","page":"Reference states","title":"Reference states","text":"(Image: )","category":"page"},{"location":"ReferenceStates/#DYCOMS_RF01","page":"Reference states","title":"DYCOMS_RF01","text":"","category":"section"},{"location":"ReferenceStates/","page":"Reference states","title":"Reference states","text":"(Image: )","category":"page"},{"location":"ReferenceStates/#GABLS","page":"Reference states","title":"GABLS","text":"","category":"section"},{"location":"ReferenceStates/","page":"Reference states","title":"Reference states","text":"(Image: )","category":"page"},{"location":"ReferenceStates/#SP","page":"Reference states","title":"SP","text":"","category":"section"},{"location":"ReferenceStates/","page":"Reference states","title":"Reference states","text":"(Image: )","category":"page"},{"location":"ReferenceStates/#DryBubble","page":"Reference states","title":"DryBubble","text":"","category":"section"},{"location":"ReferenceStates/","page":"Reference states","title":"Reference states","text":"(Image: )","category":"page"},{"location":"#TurbulenceConvection.jl","page":"Home","title":"TurbulenceConvection.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = TurbulenceConvection","category":"page"},{"location":"","page":"Home","title":"Home","text":"TurbulenceConvection.ClimaParams","category":"page"},{"location":"#TurbulenceConvection.ClimaParams","page":"Home","title":"TurbulenceConvection.ClimaParams","text":"ClimaParams\n\nThis is a module for staging experimental clima parameters– that we are unsure will be used in the final model. Once they are no longer experimental, they should be moved to CLIMAParameters.jl.\n\nTODO: move non-experimental parameters to CLIMAParameters\n\n\n\n\n\n","category":"module"}]
}
